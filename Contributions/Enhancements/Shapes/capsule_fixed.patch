Index: Box2D/Box2D/Box2D.h
===================================================================
--- Box2D/Box2D/Box2D.h	(revision 31)
+++ Box2D/Box2D/Box2D.h	(working copy)
@@ -35,6 +35,7 @@
 
 #include <Box2D/Collision/Shapes/b2CircleShape.h>
 #include <Box2D/Collision/Shapes/b2PolygonShape.h>
+#include <Box2D/Collision/Shapes/b2CapsuleShape.h>
 
 #include <Box2D/Collision/b2BroadPhase.h>
 #include <Box2D/Collision/b2Distance.h>
Index: Box2D/Box2D/Collision/b2Collision.cpp
===================================================================
--- Box2D/Box2D/Collision/b2Collision.cpp	(revision 31)
+++ Box2D/Box2D/Collision/b2Collision.cpp	(working copy)
@@ -304,3 +304,164 @@
 
 	return output.distance < 10.0f * b2_epsilon;
 }
+
+static void FindNearestPointOnLineSegment(	b2Vec2* nearest, float32* parameter,
+											const b2Vec2& A1, const b2Vec2& L, const b2Vec2& B,
+											bool infinite_line )
+{
+	float32 D = L.LengthSquared();
+	if (D < b2_epsilon * b2_epsilon)
+	{
+		*nearest = A1;
+		return;
+	}
+	
+	b2Vec2 AB = B - A1;
+	*parameter = b2Dot(L, AB) / D;
+	if (!infinite_line)
+	{
+		*parameter = b2Clamp(*parameter, 0.0f, 1.0f);
+	}
+	*nearest = A1 + *parameter * L;
+}
+
+// Based on Game Programming Gems 2
+// Fast, Robust Intersection of 3D Line Segments
+// Graham Rhodes, Applied Research Associates
+b2Vec2 b2Segment::NearestPoint(const b2Vec2& point) const
+{
+	b2Vec2 result;
+	float32 unused;
+	FindNearestPointOnLineSegment(&result, &unused, p1, p2 - p1, point, false);
+	return result;
+}
+
+static void FindNearestPointOfParallelLineSegments(	b2Vec2* x1, b2Vec2* x2,
+													const b2Segment& A, const b2Vec2& La,
+													const b2Segment& B, const b2Vec2& Lb)
+{
+	float32 s, t;
+	FindNearestPointOnLineSegment(x1, &s, A.p1, La, B.p1, true);
+	FindNearestPointOnLineSegment(x2, &t, A.p1, La, B.p2, true);
+	
+	if (s < 0.0f && t < 0.0f)
+	{
+		*x1 = A.p1;
+		if (s < t)
+			*x2 = B.p2;
+		else
+			*x2 = B.p1;
+		return;
+	}
+	
+	if (s > 1.0f && t > 1.0f)
+	{
+		*x1 = A.p2;
+		if (s < t)
+			*x2 = B.p1;
+		else
+			*x2 = B.p2;
+		return;
+	}
+	
+	float32 temp = 0.5f * (b2Clamp(s, 0.0f, 1.0f) + b2Clamp(t, 0.0f, 1.0f));
+	*x1 = A.p1 + temp * La;
+	
+	float32 unused;
+	FindNearestPointOnLineSegment(x2, &unused, B.p1, Lb, *x1, true);
+}
+
+static void AdjustNearestPoints(b2Vec2* x1, b2Vec2* x2,
+								const b2Segment& A, const b2Vec2& La,
+								const b2Segment& B, const b2Vec2& Lb,
+								float32 s, float32 t)
+{
+	if ((s < 0.0f || s > 1.0f) && (t < 0.0f || t > 1.0f))
+	{
+		s = b2Clamp(s, 0.0f, 1.0f);
+		*x1 = A.p1 + s * La;
+		FindNearestPointOnLineSegment(x2, &t, B.p1, Lb, *x1, true);
+		if (t < 0.0f || t > 1.0f)
+		{
+			t = b2Clamp(t, 0.0f, 1.0f);
+			*x2 = B.p1 + t * Lb;
+			FindNearestPointOnLineSegment(x1, &s, A.p1, La, *x2, false);
+			FindNearestPointOnLineSegment(x2, &t, B.p1, Lb, *x1, false);
+		}
+		return;
+	}
+	if (s < 0.0f || s > 1.0f)
+	{
+		s = b2Clamp(s, 0.0f, 1.0f);
+		*x1 = A.p1 + s * La;
+		FindNearestPointOnLineSegment(x2, &t, B.p1, Lb, *x1, false);
+		return;
+	}
+	b2Assert(t < 0.0f || t > 1.0f);
+	t = b2Clamp(t, 0.0f, 1.0f);
+	*x2 = B.p1 + t * Lb;
+	FindNearestPointOnLineSegment(x1, &s, A.p1, La, *x2, false);
+}
+
+static void IntersectLineSegments(	b2Vec2* x1, b2Vec2* x2,
+									const b2Segment& A, const b2Segment& B)
+{
+	float32 unused;
+	
+	b2Vec2 La = A.p2 - A.p1;
+	b2Vec2 Lb = B.p2 - B.p1;
+	float32 L11 = La.LengthSquared();
+	float32 L22 = Lb.LengthSquared();
+	
+	// Check for degenerate parameters
+	if (L11 < b2_epsilon * b2_epsilon)
+	{
+		*x1 = A.p1;
+		FindNearestPointOnLineSegment(x2, &unused, B.p1, Lb, A.p1, false);
+		return;
+	}
+	if (L22 < b2_epsilon * b2_epsilon)
+	{
+		*x2 = B.p1;
+		FindNearestPointOnLineSegment(x1, &unused, A.p1, La, B.p1, false);
+		return;
+	}
+	
+	b2Vec2 AB = B.p1 - A.p1;
+	float32 L12 = -b2Dot(La, Lb);
+	float32 DetL = L11 * L22 - L12 * L12;
+	
+	// parallel segments
+	if (b2Abs(DetL) < b2_epsilon)
+	{
+		FindNearestPointOfParallelLineSegments(x1, x2, A, La, B, Lb);
+		return;
+	}
+	
+	float32 ra = b2Dot(La, AB);
+	float32 rb = -b2Dot(Lb, AB);
+	
+	float32 t = (L11 * rb - ra * L12) / DetL;
+	float32 s = (ra - L12 * t) / L11;
+	
+	// These tests can't quite stay within B2_FLT_EPSILON
+	//b2Assert(b2Abs(s * L11 + t * L12 - ra) < .0001f);
+	//b2Assert(b2Abs(s * L12 + t * L22 - rb) < .0001f);
+	
+	*x1 = A.p1 + s * La;
+	*x2 = B.p1 + t * Lb;
+	
+	if (s < 0.0f || s > 1.0f || t < 0.0f || t > 1.0f)
+	{
+		AdjustNearestPoints(x1, x2, A, La, B, Lb, s, t);
+	}
+}
+
+// Based on Game Programming Gems 2
+// Fast, Robust Intersection of 3D Line Segments
+// Graham Rhodes, Applied Research Associates
+float32 b2Segment::Distance(b2Vec2* x1, b2Vec2* x2, const b2Segment& other) const
+{
+	IntersectLineSegments(x1, x2, *this, other);
+	return (*x2 - *x1).Length();
+}
Index: Box2D/Box2D/Collision/b2Collision.h
===================================================================
--- Box2D/Box2D/Collision/b2Collision.h	(revision 31)
+++ Box2D/Box2D/Collision/b2Collision.h	(working copy)
@@ -27,6 +27,7 @@
 /// queries, and TOI queries.
 
 class b2Shape;
+class b2CapsuleShape;
 class b2CircleShape;
 class b2PolygonShape;
 
@@ -152,6 +153,12 @@
 	/// Ray cast against this segment with another segment.
 	bool TestSegment(float32* lambda, b2Vec2* normal, const b2Segment& segment, float32 maxLambda) const;
 
+	/// Find the nearest point on this segment to the provided point.
+	b2Vec2 NearestPoint(const b2Vec2& point) const;
+	
+	/// Compute the distance to the other segment and the closest spots upon each segment.
+	float32 Distance(b2Vec2* x1, b2Vec2* x2, const b2Segment& other) const;
+	
 	b2Vec2 p1;	///< the starting point
 	b2Vec2 p2;	///< the ending point
 };
@@ -213,6 +220,7 @@
 					   const b2PolygonShape* polygon1, const b2Transform& xf1,
 					   const b2PolygonShape* polygon2, const b2Transform& xf2);
 
+
 /// Clipping for contact manifolds.
 int32 b2ClipSegmentToLine(b2ClipVertex vOut[2], const b2ClipVertex vIn[2],
 							const b2Vec2& normal, float32 offset);
Index: Box2D/Box2D/Collision/b2Distance.cpp
===================================================================
--- Box2D/Box2D/Collision/b2Distance.cpp	(revision 31)
+++ Box2D/Box2D/Collision/b2Distance.cpp	(working copy)
@@ -17,6 +17,7 @@
 */
 
 #include <Box2D/Collision/b2Distance.h>
+#include <Box2D/Collision/Shapes/b2CapsuleShape.h>
 #include <Box2D/Collision/Shapes/b2CircleShape.h>
 #include <Box2D/Collision/Shapes/b2PolygonShape.h>
 
@@ -44,6 +45,16 @@
 			m_radius = polygon->m_radius;
 		}
 		break;
+	
+	case b2Shape::e_capsule:
+	    {
+			const b2CapsuleShape* capsule = (b2CapsuleShape*)shape;
+			// HACK: reinterpret_cast to convert b2Segment* to b2Vec2*
+			m_vertices = reinterpret_cast<const b2Vec2*>(&capsule->m_segment);
+			m_count = 2;
+			m_radius = capsule->m_radius;
+	    }
+	    break;
 
 	default:
 		b2Assert(false);
Index: Box2D/Box2D/Collision/Shapes/b2CapsuleShape.cpp
===================================================================
--- Box2D/Box2D/Collision/Shapes/b2CapsuleShape.cpp	(revision 0)
+++ Box2D/Box2D/Collision/Shapes/b2CapsuleShape.cpp	(revision 0)
@@ -0,0 +1,197 @@
+/*
+* Copyright (c) 2006-2009 Erin Catto http://www.gphysics.com
+*
+* This software is provided 'as-is', without any express or implied
+* warranty.  In no event will the authors be held liable for any damages
+* arising from the use of this software.
+* Permission is granted to anyone to use this software for any purpose,
+* including commercial applications, and to alter it and redistribute it
+* freely, subject to the following restrictions:
+* 1. The origin of this software must not be misrepresented; you must not
+* claim that you wrote the original software. If you use this software
+* in a product, an acknowledgment in the product documentation would be
+* appreciated but is not required.
+* 2. Altered source versions must be plainly marked as such, and must not be
+* misrepresented as being the original software.
+* 3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include <Box2D/Collision/Shapes/b2CapsuleShape.h>
+#include <new>
+
+void b2CapsuleShape::SetByExtentsX(float32 radius, float32 length)
+{
+	m_radius = radius;
+	float32 half = length * 0.5f;
+	m_segment.p1 = b2Vec2(-half, 0.0f);
+	m_segment.p2 = b2Vec2(half, 0.0f);
+}
+
+void b2CapsuleShape::SetByExtentsX(float32 radius, float32 length,
+									  const b2Vec2& center, float32 angle)
+{
+	SetByExtentsX(radius, length);
+	b2Transform xf;
+	xf.position = center;
+	xf.R.Set(angle);
+	
+	m_segment.p1 = b2Mul(xf, m_segment.p1);
+	m_segment.p2 = b2Mul(xf, m_segment.p2);
+}
+
+
+void b2CapsuleShape::SetByExtentsY(float32 radius, float32 height)
+{
+	m_radius = radius;
+	float32 half = height * 0.5f;
+	m_segment.p1 = b2Vec2(0.0f, -half);
+	m_segment.p2 = b2Vec2(0.0f, half);
+}
+
+void b2CapsuleShape::SetByExtentsY(float32 radius, float32 height,
+									  const b2Vec2& center, float32 angle)
+{
+	SetByExtentsY(radius, height);
+	b2Transform xf;
+	xf.position = center;
+	xf.R.Set(angle);
+	
+	m_segment.p1 = b2Mul(xf, m_segment.p1);
+	m_segment.p2 = b2Mul(xf, m_segment.p2);
+}
+
+b2Shape* b2CapsuleShape::Clone(b2BlockAllocator* allocator) const
+{
+	void* mem = allocator->Allocate(sizeof(b2CapsuleShape));
+	b2CapsuleShape* clone = new (mem) b2CapsuleShape;
+	*clone = *this;
+	return clone;
+}
+
+bool b2CapsuleShape::TestPoint(const b2Transform& transform, const b2Vec2& p) const
+{
+	b2Vec2 local = b2MulT(transform, p);
+	b2Vec2 d = m_segment.NearestPoint(local) - local;
+	return (d.LengthSquared() <= m_radius * m_radius);
+}
+
+bool b2CapsuleShape::RayCast(b2RayCastOutput* output, const b2RayCastInput& input, const b2Transform& transform) const
+{
+	// Test for starting inside first significantly reduces complexity
+	if (TestPoint(transform, input.p1)) {
+	    return false;
+	}
+	
+	// Project capsule to world
+	b2Segment capsule;
+	capsule.p1 = b2Mul(transform, m_segment.p1);
+	capsule.p2 = b2Mul(transform, m_segment.p2);
+	b2Vec2 d = capsule.p2 - capsule.p1;
+	
+	// Consider "cylinder"
+	
+	// Figure out signed distance from p1 to infinite capsule line
+	float32 ld = b2Cross(d, capsule.p1 - input.p1);
+	
+	// Only bother if we don't start inside the infinite "cylinder"
+	if (!(ld * ld <= m_radius * m_radius * d.LengthSquared())) {
+		
+		// Find a perpendicular vector to the intersect, with length equal to radius
+		b2Vec2 perp = b2Cross(d, m_radius / d.Length());
+		
+		// Push the capsule segment by that vector
+		// Must swap if coming from the other side
+		b2Segment boundary;
+		if (ld < 0) {
+			boundary.p1 = capsule.p2 - perp;
+			boundary.p2 = capsule.p1 - perp;
+		}
+		else {
+			boundary.p1 = capsule.p1 + perp;
+			boundary.p2 = capsule.p2 + perp;
+		}
+		
+		// Check intersection against the adjusted segments.
+		b2Segment inputSegment;
+		inputSegment.p1 = input.p1;
+		inputSegment.p2 = input.p2;
+		if (boundary.TestSegment(&output->fraction, &output->normal, inputSegment, input.maxFraction))
+			return true;
+	}
+	
+	// Consider circular caps
+	
+	// Precompute some circle values
+	b2Vec2 r = input.p2 - input.p1;
+	float32 rr = r.LengthSquared();
+	
+	// Check for short segment
+	if (rr < b2_epsilon)
+	{
+		return false;
+	}
+	
+	// Check the circle caps
+	b2Vec2 center = capsule.p1;
+	for (int i = 0; i < 2; ++i)
+	{
+		b2Vec2 s = input.p1 - center;
+		float32 b = b2Dot(s, s) - m_radius * m_radius;
+		
+		// Should not start inside
+		b2Assert(!(b < 0.0f));
+		
+		// Solve quadratic equation.
+		float32 c =  b2Dot(s, r);
+		float32 sigma = c * c - rr * b;
+		
+		// Check for negative discriminant.
+		if (!(sigma < 0.0f))
+		{
+			// Find the point of intersection of the line with the circle.
+			float32 a = -(c + b2Sqrt(sigma));
+			
+			// Is the intersection point on the segment?
+			if (0.0f <= a && a <= input.maxFraction * rr)
+			{
+				a /= rr;
+				output->fraction = a;
+				output->normal = s + a * r;
+				output->normal.Normalize();
+				return true;
+			}
+		}
+		
+		// switch to the next circle
+		center = capsule.p2;
+	}
+	
+	return false;
+}
+
+void b2CapsuleShape::ComputeAABB(b2AABB* aabb, const b2Transform& transform) const
+{
+	b2Vec2 p1 = transform.position + b2Mul(transform.R, m_segment.p1);
+	b2Vec2 p2 = transform.position + b2Mul(transform.R, m_segment.p2);
+	b2Vec2 min = b2Min(p1, p2);
+	b2Vec2 max = b2Max(p1, p2);
+	aabb->lowerBound.Set(min.x - m_radius, min.y - m_radius);
+	aabb->upperBound.Set(max.x + m_radius, max.y + m_radius);
+}
+
+void b2CapsuleShape::ComputeMass(b2MassData* massData, float32 density) const
+{
+	// Area of rectangle + 2 half circles
+	float32 rectHeight = (m_segment.p2 - m_segment.p1).Length();
+	float32 rectMass = density * rectHeight * m_radius;
+	float32 circleMass = density * b2_pi * m_radius * m_radius;
+	massData->mass = rectMass + circleMass;
+	massData->center = 0.5f * (m_segment.p1 + m_segment.p2);
+
+	// inertia about the local origin
+	float32 rectInertia = rectMass * (rectHeight * rectHeight + m_radius * m_radius) / 12.0f;
+	float32 circleInertia = circleMass * (0.5f * m_radius * m_radius + rectHeight * rectHeight * .25f);
+	massData->I = rectInertia + circleInertia + massData->mass * massData->center.LengthSquared();
+}
+
+
Index: Box2D/Box2D/Collision/Shapes/b2CapsuleShape.h
===================================================================
--- Box2D/Box2D/Collision/Shapes/b2CapsuleShape.h	(revision 0)
+++ Box2D/Box2D/Collision/Shapes/b2CapsuleShape.h	(revision 0)
@@ -0,0 +1,106 @@
+/*
+* Copyright (c) 2006-2009 Erin Catto http://www.gphysics.com
+*
+* This software is provided 'as-is', without any express or implied
+* warranty.  In no event will the authors be held liable for any damages
+* arising from the use of this software.
+* Permission is granted to anyone to use this software for any purpose,
+* including commercial applications, and to alter it and redistribute it
+* freely, subject to the following restrictions:
+* 1. The origin of this software must not be misrepresented; you must not
+* claim that you wrote the original software. If you use this software
+* in a product, an acknowledgment in the product documentation would be
+* appreciated but is not required.
+* 2. Altered source versions must be plainly marked as such, and must not be
+* misrepresented as being the original software.
+* 3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef B2_CAPSULE_SHAPE_H
+#define B2_CAPSULE_SHAPE_H
+
+#include <Box2D/Collision/Shapes/b2Shape.h>
+
+/// A circle shape.
+class b2CapsuleShape : public b2Shape
+{
+public:
+	b2CapsuleShape();
+	
+	/// Set to a capsule across the X axis, with given width between focii.
+	void SetByExtentsX(float32 radius, float32 width);
+	/// Set to a capsule across the X axis, rotated and transposed.
+	void SetByExtentsX(float32 radius, float32 width,
+					    const b2Vec2& center, float32 angle);
+    
+	/// Set to a capsule across the Y axis, with given height between focii.
+	void SetByExtentsY(float32 radius, float32 height);
+	/// Set to a capsule across the Y axis, rotated and transposed.
+	void SetByExtentsY(float32 radius, float32 height,
+					    const b2Vec2& center, float32 angle);
+
+	/// Implement b2Shape.
+	b2Shape* Clone(b2BlockAllocator* allocator) const;
+
+	/// Implement b2Shape.
+	bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;
+
+	/// Implement b2Shape.
+	bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input, const b2Transform& transform) const;
+
+	/// @see b2Shape::ComputeAABB
+	void ComputeAABB(b2AABB* aabb, const b2Transform& transform) const;
+
+	/// @see b2Shape::ComputeMass
+	void ComputeMass(b2MassData* massData, float32 density) const;
+
+	/// Get the supporting vertex index in the given direction.
+	int32 GetSupport(const b2Vec2& d) const;
+
+	/// Get the supporting vertex in the given direction.
+	const b2Vec2& GetSupportVertex(const b2Vec2& d) const;
+
+	/// Get the vertex count.
+	int32 GetVertexCount() const { return 2; }
+
+	/// Get a vertex by index. Used by b2Distance.
+	const b2Vec2& GetVertex(int32 index) const;
+
+	/// Position
+	b2Segment m_segment;
+};
+
+inline b2CapsuleShape::b2CapsuleShape()
+{
+	m_type = e_capsule;
+	m_radius = 0.0f;
+	m_segment.p1.SetZero();
+	m_segment.p2.SetZero();
+}
+
+
+inline int32 b2CapsuleShape::GetSupport(const b2Vec2 &d) const
+{
+    if ((m_segment.p1 - d).LengthSquared() <= (m_segment.p2 - d).LengthSquared()) {
+        return 0;
+    }
+	return 1;
+}
+
+inline const b2Vec2& b2CapsuleShape::GetSupportVertex(const b2Vec2 &d) const
+{
+    return GetVertex(GetSupport(d));
+}
+
+inline const b2Vec2& b2CapsuleShape::GetVertex(int32 index) const
+{
+	b2Assert(index == 0 || index == 1);
+    if (index != 0) {
+        return m_segment.p2;
+    }
+    return m_segment.p1;
+}
+
+
+
+#endif
Index: Box2D/Box2D/Collision/Shapes/b2Shape.h
===================================================================
--- Box2D/Box2D/Collision/Shapes/b2Shape.h	(revision 31)
+++ Box2D/Box2D/Collision/Shapes/b2Shape.h	(working copy)
@@ -49,7 +49,8 @@
 		e_unknown= -1,
 		e_circle = 0,
 		e_polygon = 1,
-		e_typeCount = 2,
+		e_capsule = 2,
+		e_typeCount = 3,
 	};
 
 	b2Shape() { m_type = e_unknown; }
Index: Box2D/Box2D/Dynamics/b2Fixture.cpp
===================================================================
--- Box2D/Box2D/Dynamics/b2Fixture.cpp	(revision 31)
+++ Box2D/Box2D/Dynamics/b2Fixture.cpp	(working copy)
@@ -18,6 +18,7 @@
 
 #include <Box2D/Dynamics/b2Fixture.h>
 #include <Box2D/Dynamics/Contacts/b2Contact.h>
+#include <Box2D/Collision/Shapes/b2CapsuleShape.h>
 #include <Box2D/Collision/Shapes/b2CircleShape.h>
 #include <Box2D/Collision/Shapes/b2PolygonShape.h>
 #include <Box2D/Collision/b2BroadPhase.h>
@@ -82,6 +83,14 @@
 			allocator->Free(s, sizeof(b2PolygonShape));
 		}
 		break;
+	
+	case b2Shape::e_capsule:
+	    {
+			b2CapsuleShape* s = (b2CapsuleShape*)m_shape;
+			s->~b2CapsuleShape();
+			allocator->Free(s, sizeof(b2CapsuleShape));
+	    }
+	    break;
 
 	default:
 		b2Assert(false);
Index: Box2D/Box2D/Dynamics/b2World.cpp
===================================================================
--- Box2D/Box2D/Dynamics/b2World.cpp	(revision 31)
+++ Box2D/Box2D/Dynamics/b2World.cpp	(working copy)
@@ -25,6 +25,7 @@
 #include <Box2D/Dynamics/Contacts/b2ContactSolver.h>
 #include <Box2D/Collision/b2Collision.h>
 #include <Box2D/Collision/b2BroadPhase.h>
+#include <Box2D/Collision/Shapes/b2CapsuleShape.h>
 #include <Box2D/Collision/Shapes/b2CircleShape.h>
 #include <Box2D/Collision/Shapes/b2PolygonShape.h>
 #include <new>
@@ -994,6 +995,18 @@
 			m_debugDraw->DrawSolidPolygon(vertices, vertexCount, color);
 		}
 		break;
+	
+	case b2Shape::e_capsule:
+		{
+			b2CapsuleShape* capsule = (b2CapsuleShape*)fixture->GetShape();
+			
+			b2Vec2 p1 = b2Mul(xf, capsule->m_segment.p1);
+			b2Vec2 p2 = b2Mul(xf, capsule->m_segment.p2);
+			float32 radius = capsule->m_radius;
+
+			m_debugDraw->DrawSolidCapsule(p1, p2, radius, color);
+		}
+		break;
 	}
 }
 
Index: Box2D/Box2D/Dynamics/b2WorldCallbacks.h
===================================================================
--- Box2D/Box2D/Dynamics/b2WorldCallbacks.h	(revision 31)
+++ Box2D/Box2D/Dynamics/b2WorldCallbacks.h	(working copy)
@@ -205,6 +205,12 @@
 	/// Draw a solid circle.
 	virtual void DrawSolidCircle(const b2Vec2& center, float32 radius, const b2Vec2& axis, const b2Color& color) = 0;
 	
+	/// Draw a capsule.
+	virtual void DrawCapsule(const b2Vec2& p1, const b2Vec2& p2, float32 radius, const b2Color& color) = 0;
+	
+	/// Draw a solid capsule.
+	virtual void DrawSolidCapsule(const b2Vec2& p1, const b2Vec2& p2, float32 radius, const b2Color& color) = 0;
+	
 	/// Draw a line segment.
 	virtual void DrawSegment(const b2Vec2& p1, const b2Vec2& p2, const b2Color& color) = 0;
 
Index: Box2D/Box2D/Dynamics/Contacts/b2CapsuleAndCircleContact.cpp
===================================================================
--- Box2D/Box2D/Dynamics/Contacts/b2CapsuleAndCircleContact.cpp	(revision 0)
+++ Box2D/Box2D/Dynamics/Contacts/b2CapsuleAndCircleContact.cpp	(revision 0)
@@ -0,0 +1,63 @@
+/*
+* Copyright (c) 2006-2009 Erin Catto http://www.gphysics.com
+*
+* This software is provided 'as-is', without any express or implied
+* warranty.  In no event will the authors be held liable for any damages
+* arising from the use of this software.
+* Permission is granted to anyone to use this software for any purpose,
+* including commercial applications, and to alter it and redistribute it
+* freely, subject to the following restrictions:
+* 1. The origin of this software must not be misrepresented; you must not
+* claim that you wrote the original software. If you use this software
+* in a product, an acknowledgment in the product documentation would be
+* appreciated but is not required.
+* 2. Altered source versions must be plainly marked as such, and must not be
+* misrepresented as being the original software.
+* 3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include <Box2D/Dynamics/Contacts/b2CapsuleAndCircleContact.h>
+#include <Box2D/Dynamics/b2Body.h>
+#include <Box2D/Dynamics/b2Fixture.h>
+#include <Box2D/Dynamics/b2WorldCallbacks.h>
+#include <Box2D/Common/b2BlockAllocator.h>
+#include <Box2D/Collision/b2TimeOfImpact.h>
+#include <Box2D/Collision/Shapes/b2CapsuleShape.h>
+#include <Box2D/Collision/Shapes/b2PolygonShape.h>
+
+#include <new>
+
+b2Contact* b2CapsuleAndCircleContact::Create(b2Fixture* fixtureA, b2Fixture* fixtureB, b2BlockAllocator* allocator)
+{
+	void* mem = allocator->Allocate(sizeof(b2CapsuleAndCircleContact));
+	return new (mem) b2CapsuleAndCircleContact(fixtureA, fixtureB);
+}
+
+void b2CapsuleAndCircleContact::Destroy(b2Contact* contact, b2BlockAllocator* allocator)
+{
+	((b2CapsuleAndCircleContact*)contact)->~b2CapsuleAndCircleContact();
+	allocator->Free(contact, sizeof(b2CapsuleAndCircleContact));
+}
+
+b2CapsuleAndCircleContact::b2CapsuleAndCircleContact(b2Fixture* fixtureA, b2Fixture* fixtureB)
+	: b2Contact(fixtureA, fixtureB)
+{
+	b2Assert(m_fixtureA->GetType() == b2Shape::e_capsule);
+	b2Assert(m_fixtureB->GetType() == b2Shape::e_circle);
+}
+
+void b2CapsuleAndCircleContact::Evaluate()
+{
+	b2Body* bodyA = m_fixtureA->GetBody();
+	b2Body* bodyB = m_fixtureB->GetBody();
+	
+	b2CapsuleShape* capsule = (b2CapsuleShape*)m_fixtureA->GetShape();
+	
+	b2PolygonShape polygon;
+	polygon.SetAsEdge(capsule->m_segment.p1, capsule->m_segment.p2);
+	polygon.m_radius = capsule->m_radius;
+
+	b2CollidePolygonAndCircle(	&m_manifold,
+						&polygon, bodyA->GetTransform(),
+						(b2CircleShape*)m_fixtureB->GetShape(), bodyB->GetTransform());
+}
Index: Box2D/Box2D/Dynamics/Contacts/b2CapsuleAndCircleContact.h
===================================================================
--- Box2D/Box2D/Dynamics/Contacts/b2CapsuleAndCircleContact.h	(revision 0)
+++ Box2D/Box2D/Dynamics/Contacts/b2CapsuleAndCircleContact.h	(revision 0)
@@ -0,0 +1,38 @@
+/*
+* Copyright (c) 2006-2009 Erin Catto http://www.gphysics.com
+*
+* This software is provided 'as-is', without any express or implied
+* warranty.  In no event will the authors be held liable for any damages
+* arising from the use of this software.
+* Permission is granted to anyone to use this software for any purpose,
+* including commercial applications, and to alter it and redistribute it
+* freely, subject to the following restrictions:
+* 1. The origin of this software must not be misrepresented; you must not
+* claim that you wrote the original software. If you use this software
+* in a product, an acknowledgment in the product documentation would be
+* appreciated but is not required.
+* 2. Altered source versions must be plainly marked as such, and must not be
+* misrepresented as being the original software.
+* 3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef B2_CAPSULE_AND_CIRCLE_CONTACT_H
+#define B2_CAPSULE_AND_CIRCLE_CONTACT_H
+
+#include <Box2D/Dynamics/Contacts/b2Contact.h>
+
+class b2BlockAllocator;
+
+class b2CapsuleAndCircleContact : public b2Contact
+{
+public:
+	static b2Contact* Create(b2Fixture* fixtureA, b2Fixture* fixtureB, b2BlockAllocator* allocator);
+	static void Destroy(b2Contact* contact, b2BlockAllocator* allocator);
+
+	b2CapsuleAndCircleContact(b2Fixture* fixtureA, b2Fixture* fixtureB);
+	~b2CapsuleAndCircleContact() {}
+
+	void Evaluate();
+};
+
+#endif
Index: Box2D/Box2D/Dynamics/Contacts/b2CapsuleContact.cpp
===================================================================
--- Box2D/Box2D/Dynamics/Contacts/b2CapsuleContact.cpp	(revision 0)
+++ Box2D/Box2D/Dynamics/Contacts/b2CapsuleContact.cpp	(revision 0)
@@ -0,0 +1,66 @@
+/*
+* Copyright (c) 2006-2009 Erin Catto http://www.gphysics.com
+*
+* This software is provided 'as-is', without any express or implied
+* warranty.  In no event will the authors be held liable for any damages
+* arising from the use of this software.
+* Permission is granted to anyone to use this software for any purpose,
+* including commercial applications, and to alter it and redistribute it
+* freely, subject to the following restrictions:
+* 1. The origin of this software must not be misrepresented; you must not
+* claim that you wrote the original software. If you use this software
+* in a product, an acknowledgment in the product documentation would be
+* appreciated but is not required.
+* 2. Altered source versions must be plainly marked as such, and must not be
+* misrepresented as being the original software.
+* 3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include <Box2D/Dynamics/Contacts/b2CapsuleContact.h>
+#include <Box2D/Dynamics/b2Body.h>
+#include <Box2D/Dynamics/b2Fixture.h>
+#include <Box2D/Dynamics/b2WorldCallbacks.h>
+#include <Box2D/Common/b2BlockAllocator.h>
+#include <Box2D/Collision/b2TimeOfImpact.h>
+#include <Box2D/Collision/Shapes/b2CapsuleShape.h>
+#include <Box2D/Collision/Shapes/b2PolygonShape.h>
+
+#include <new>
+
+b2Contact* b2CapsuleContact::Create(b2Fixture* fixtureA, b2Fixture* fixtureB, b2BlockAllocator* allocator)
+{
+	void* mem = allocator->Allocate(sizeof(b2CapsuleContact));
+	return new (mem) b2CapsuleContact(fixtureA, fixtureB);
+}
+
+void b2CapsuleContact::Destroy(b2Contact* contact, b2BlockAllocator* allocator)
+{
+	((b2CapsuleContact*)contact)->~b2CapsuleContact();
+	allocator->Free(contact, sizeof(b2CapsuleContact));
+}
+
+b2CapsuleContact::b2CapsuleContact(b2Fixture* fixtureA, b2Fixture* fixtureB)
+	: b2Contact(fixtureA, fixtureB)
+{
+	b2Assert(m_fixtureA->GetType() == b2Shape::e_capsule);
+	b2Assert(m_fixtureB->GetType() == b2Shape::e_capsule);
+}
+
+void b2CapsuleContact::Evaluate()
+{
+	b2Body* bodyA = m_fixtureA->GetBody();
+	b2Body* bodyB = m_fixtureB->GetBody();
+
+	b2CapsuleShape* capsule1 = (b2CapsuleShape*)m_fixtureA->GetShape();
+	b2CapsuleShape* capsule2 = (b2CapsuleShape*)m_fixtureB->GetShape();
+	
+	b2PolygonShape polygon1, polygon2;
+	polygon1.SetAsEdge(capsule1->m_segment.p1, capsule1->m_segment.p2);
+	polygon2.SetAsEdge(capsule2->m_segment.p1, capsule2->m_segment.p2);
+	polygon1.m_radius = capsule1->m_radius;
+	polygon2.m_radius = capsule2->m_radius;
+
+	b2CollidePolygons(	&m_manifold,
+						&polygon1, bodyA->GetTransform(),
+						&polygon2, bodyB->GetTransform());
+}
Index: Box2D/Box2D/Dynamics/Contacts/b2CapsuleContact.h
===================================================================
--- Box2D/Box2D/Dynamics/Contacts/b2CapsuleContact.h	(revision 0)
+++ Box2D/Box2D/Dynamics/Contacts/b2CapsuleContact.h	(revision 0)
@@ -0,0 +1,38 @@
+/*
+* Copyright (c) 2006-2009 Erin Catto http://www.gphysics.com
+*
+* This software is provided 'as-is', without any express or implied
+* warranty.  In no event will the authors be held liable for any damages
+* arising from the use of this software.
+* Permission is granted to anyone to use this software for any purpose,
+* including commercial applications, and to alter it and redistribute it
+* freely, subject to the following restrictions:
+* 1. The origin of this software must not be misrepresented; you must not
+* claim that you wrote the original software. If you use this software
+* in a product, an acknowledgment in the product documentation would be
+* appreciated but is not required.
+* 2. Altered source versions must be plainly marked as such, and must not be
+* misrepresented as being the original software.
+* 3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef B2_CAPSULE_CONTACT_H
+#define B2_CAPSULE_CONTACT_H
+
+#include <Box2D/Dynamics/Contacts/b2Contact.h>
+
+class b2BlockAllocator;
+
+class b2CapsuleContact : public b2Contact
+{
+public:
+	static b2Contact* Create(b2Fixture* fixtureA, b2Fixture* fixtureB, b2BlockAllocator* allocator);
+	static void Destroy(b2Contact* contact, b2BlockAllocator* allocator);
+
+	b2CapsuleContact(b2Fixture* fixtureA, b2Fixture* fixtureB);
+	~b2CapsuleContact() {}
+
+	void Evaluate();
+};
+
+#endif
Index: Box2D/Box2D/Dynamics/Contacts/b2Contact.cpp
===================================================================
--- Box2D/Box2D/Dynamics/Contacts/b2Contact.cpp	(revision 31)
+++ Box2D/Box2D/Dynamics/Contacts/b2Contact.cpp	(working copy)
@@ -17,7 +17,10 @@
 */
 
 #include <Box2D/Dynamics/Contacts/b2Contact.h>
+#include <Box2D/Dynamics/Contacts/b2CapsuleContact.h>
+#include <Box2D/Dynamics/Contacts/b2CapsuleAndCircleContact.h>
 #include <Box2D/Dynamics/Contacts/b2CircleContact.h>
+#include <Box2D/Dynamics/Contacts/b2PolygonAndCapsuleContact.h>
 #include <Box2D/Dynamics/Contacts/b2PolygonAndCircleContact.h>
 #include <Box2D/Dynamics/Contacts/b2PolygonContact.h>
 #include <Box2D/Dynamics/Contacts/b2ContactSolver.h>
@@ -38,6 +41,10 @@
 	AddType(b2CircleContact::Create, b2CircleContact::Destroy, b2Shape::e_circle, b2Shape::e_circle);
 	AddType(b2PolygonAndCircleContact::Create, b2PolygonAndCircleContact::Destroy, b2Shape::e_polygon, b2Shape::e_circle);
 	AddType(b2PolygonContact::Create, b2PolygonContact::Destroy, b2Shape::e_polygon, b2Shape::e_polygon);
+	
+	AddType(b2CapsuleContact::Create, b2CapsuleContact::Destroy, b2Shape::e_capsule, b2Shape::e_capsule);
+	AddType(b2CapsuleAndCircleContact::Create, b2CapsuleAndCircleContact::Destroy, b2Shape::e_capsule, b2Shape::e_circle);
+	AddType(b2PolygonAndCapsuleContact::Create, b2PolygonAndCapsuleContact::Destroy, b2Shape::e_polygon, b2Shape::e_capsule);
 }
 
 void b2Contact::AddType(b2ContactCreateFcn* createFcn, b2ContactDestroyFcn* destoryFcn,
Index: Box2D/Box2D/Dynamics/Contacts/b2PolygonAndCapsuleContact.cpp
===================================================================
--- Box2D/Box2D/Dynamics/Contacts/b2PolygonAndCapsuleContact.cpp	(revision 0)
+++ Box2D/Box2D/Dynamics/Contacts/b2PolygonAndCapsuleContact.cpp	(revision 0)
@@ -0,0 +1,63 @@
+/*
+* Copyright (c) 2006-2009 Erin Catto http://www.gphysics.com
+*
+* This software is provided 'as-is', without any express or implied
+* warranty.  In no event will the authors be held liable for any damages
+* arising from the use of this software.
+* Permission is granted to anyone to use this software for any purpose,
+* including commercial applications, and to alter it and redistribute it
+* freely, subject to the following restrictions:
+* 1. The origin of this software must not be misrepresented; you must not
+* claim that you wrote the original software. If you use this software
+* in a product, an acknowledgment in the product documentation would be
+* appreciated but is not required.
+* 2. Altered source versions must be plainly marked as such, and must not be
+* misrepresented as being the original software.
+* 3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include <Box2D/Dynamics/Contacts/b2PolygonAndCapsuleContact.h>
+#include <Box2D/Dynamics/b2Body.h>
+#include <Box2D/Dynamics/b2Fixture.h>
+#include <Box2D/Dynamics/b2WorldCallbacks.h>
+#include <Box2D/Common/b2BlockAllocator.h>
+#include <Box2D/Collision/b2TimeOfImpact.h>
+#include <Box2D/Collision/Shapes/b2CapsuleShape.h>
+#include <Box2D/Collision/Shapes/b2PolygonShape.h>
+
+#include <new>
+
+b2Contact* b2PolygonAndCapsuleContact::Create(b2Fixture* fixtureA, b2Fixture* fixtureB, b2BlockAllocator* allocator)
+{
+	void* mem = allocator->Allocate(sizeof(b2PolygonAndCapsuleContact));
+	return new (mem) b2PolygonAndCapsuleContact(fixtureA, fixtureB);
+}
+
+void b2PolygonAndCapsuleContact::Destroy(b2Contact* contact, b2BlockAllocator* allocator)
+{
+	((b2PolygonAndCapsuleContact*)contact)->~b2PolygonAndCapsuleContact();
+	allocator->Free(contact, sizeof(b2PolygonAndCapsuleContact));
+}
+
+b2PolygonAndCapsuleContact::b2PolygonAndCapsuleContact(b2Fixture* fixtureA, b2Fixture* fixtureB)
+	: b2Contact(fixtureA, fixtureB)
+{
+	b2Assert(m_fixtureA->GetType() == b2Shape::e_polygon);
+	b2Assert(m_fixtureB->GetType() == b2Shape::e_capsule);
+}
+
+void b2PolygonAndCapsuleContact::Evaluate()
+{
+	b2Body* bodyA = m_fixtureA->GetBody();
+	b2Body* bodyB = m_fixtureB->GetBody();
+
+	b2CapsuleShape* capsule = (b2CapsuleShape*)m_fixtureB->GetShape();
+	
+	b2PolygonShape polygon;
+	polygon.SetAsEdge(capsule->m_segment.p1, capsule->m_segment.p2);
+	polygon.m_radius = capsule->m_radius;
+
+	b2CollidePolygons(	&m_manifold,
+						(b2PolygonShape*)m_fixtureA->GetShape(), bodyA->GetTransform(),
+						&polygon, bodyB->GetTransform());
+}
Index: Box2D/Box2D/Dynamics/Contacts/b2PolygonAndCapsuleContact.h
===================================================================
--- Box2D/Box2D/Dynamics/Contacts/b2PolygonAndCapsuleContact.h	(revision 0)
+++ Box2D/Box2D/Dynamics/Contacts/b2PolygonAndCapsuleContact.h	(revision 0)
@@ -0,0 +1,38 @@
+/*
+* Copyright (c) 2006-2009 Erin Catto http://www.gphysics.com
+*
+* This software is provided 'as-is', without any express or implied
+* warranty.  In no event will the authors be held liable for any damages
+* arising from the use of this software.
+* Permission is granted to anyone to use this software for any purpose,
+* including commercial applications, and to alter it and redistribute it
+* freely, subject to the following restrictions:
+* 1. The origin of this software must not be misrepresented; you must not
+* claim that you wrote the original software. If you use this software
+* in a product, an acknowledgment in the product documentation would be
+* appreciated but is not required.
+* 2. Altered source versions must be plainly marked as such, and must not be
+* misrepresented as being the original software.
+* 3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef B2_POLYGON_AND_CAPSULE_CONTACT_H
+#define B2_POLYGON_AND_CAPSULE_CONTACT_H
+
+#include <Box2D/Dynamics/Contacts/b2Contact.h>
+
+class b2BlockAllocator;
+
+class b2PolygonAndCapsuleContact : public b2Contact
+{
+public:
+	static b2Contact* Create(b2Fixture* fixtureA, b2Fixture* fixtureB, b2BlockAllocator* allocator);
+	static void Destroy(b2Contact* contact, b2BlockAllocator* allocator);
+
+	b2PolygonAndCapsuleContact(b2Fixture* fixtureA, b2Fixture* fixtureB);
+	~b2PolygonAndCapsuleContact() {}
+
+	void Evaluate();
+};
+
+#endif
Index: Box2D/Examples/Testbed/Framework/Render.cpp
===================================================================
--- Box2D/Examples/Testbed/Framework/Render.cpp	(revision 31)
+++ Box2D/Examples/Testbed/Framework/Render.cpp	(working copy)
@@ -110,6 +110,83 @@
 	glEnd();
 }
 
+void DebugDraw::DrawCapsule(const b2Vec2& p1, const b2Vec2& p2, float32 radius, const b2Color& color)
+{
+    b2Vec2 displacement = p2 - p1;
+    displacement.Normalize();
+    float32 startingAngle = atan2f(displacement.y, displacement.x) + b2_pi / 2;
+    
+	const float32 k_segments = 8.0f;
+	const float32 k_increment = b2_pi / k_segments;
+	float32 theta = startingAngle;
+	glColor3f(color.r, color.g, color.b);
+	glBegin(GL_LINE_LOOP);
+	for (int32 i = 0; i < k_segments; ++i)
+	{
+		b2Vec2 v = p1 + radius * b2Vec2(cosf(theta), sinf(theta));
+		glVertex2f(v.x, v.y);
+		theta += k_increment;
+	}
+	for (int32 i = 0; i < k_segments; ++i)
+	{
+		b2Vec2 v = p2 + radius * b2Vec2(cosf(theta), sinf(theta));
+		glVertex2f(v.x, v.y);
+		theta += k_increment;
+	}
+	glEnd();
+}
+
+void DebugDraw::DrawSolidCapsule(const b2Vec2& p1, const b2Vec2& p2, float32 radius, const b2Color& color)
+{
+    b2Vec2 displacement = p2 - p1;
+    displacement.Normalize();
+    float32 startingAngle = atan2f(displacement.y, displacement.x) + b2_pi / 2;
+    
+	const float32 k_segments = 8.0f;
+	const float32 k_increment = b2_pi / k_segments;
+	float32 theta = startingAngle;
+	glEnable(GL_BLEND);
+	glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+	glColor4f(0.5f * color.r, 0.5f * color.g, 0.5f * color.b, 0.5f);
+	glBegin(GL_TRIANGLE_FAN);
+	for (int32 i = 0; i < k_segments; ++i)
+	{
+		b2Vec2 v = p1 + radius * b2Vec2(cosf(theta), sinf(theta));
+		glVertex2f(v.x, v.y);
+		theta += k_increment;
+	}
+	for (int32 i = 0; i < k_segments; ++i)
+	{
+		b2Vec2 v = p2 + radius * b2Vec2(cosf(theta), sinf(theta));
+		glVertex2f(v.x, v.y);
+		theta += k_increment;
+	}
+	glEnd();
+	glDisable(GL_BLEND);
+	
+	theta = startingAngle;
+	glColor4f(color.r, color.g, color.b, 1.0f);
+	glBegin(GL_LINE_LOOP);
+	for (int32 i = 0; i < k_segments; ++i)
+	{
+		b2Vec2 v = p1 + radius * b2Vec2(cosf(theta), sinf(theta));
+		glVertex2f(v.x, v.y);
+		theta += k_increment;
+	}
+	for (int32 i = 0; i < k_segments; ++i)
+	{
+		b2Vec2 v = p2 + radius * b2Vec2(cosf(theta), sinf(theta));
+		glVertex2f(v.x, v.y);
+		theta += k_increment;
+	}
+	glEnd();
+    
+	glBegin(GL_LINES);
+	glVertex2f(p1.x, p1.y);
+	glVertex2f(p2.x, p2.y);
+	glEnd();
+}
+
 void DebugDraw::DrawSegment(const b2Vec2& p1, const b2Vec2& p2, const b2Color& color)
 {
 	glColor3f(color.r, color.g, color.b);
Index: Box2D/Examples/Testbed/Framework/Render.h
===================================================================
--- Box2D/Examples/Testbed/Framework/Render.h	(revision 31)
+++ Box2D/Examples/Testbed/Framework/Render.h	(working copy)
@@ -36,6 +36,10 @@
 
 	void DrawSolidCircle(const b2Vec2& center, float32 radius, const b2Vec2& axis, const b2Color& color);
 
+	void DrawCapsule(const b2Vec2& p1, const b2Vec2& p2, float32 radius, const b2Color& color);
+
+	void DrawSolidCapsule(const b2Vec2& p1, const b2Vec2& p2, float32 radius, const b2Color& color);
+	
 	void DrawSegment(const b2Vec2& p1, const b2Vec2& p2, const b2Color& color);
 
 	void DrawTransform(const b2Transform& xf);
Index: Box2D/Examples/Testbed/Tests/PolyShapes.h
===================================================================
--- Box2D/Examples/Testbed/Tests/PolyShapes.h	(revision 31)
+++ Box2D/Examples/Testbed/Tests/PolyShapes.h	(working copy)
@@ -163,6 +163,14 @@
 			m_circle.m_radius = 0.5f;
 		}
 
+		{
+		    m_capsules[0].SetByExtentsX(0.5f, 0.5f);
+		}
+
+		{
+		    m_capsules[1].SetByExtentsY(0.1f, 1.8f, b2Vec2(0.0f, 1.0f), 0.0f);
+		}
+		
 		m_bodyIndex = 0;
 		memset(m_bodies, 0, sizeof(m_bodies));
 	}
@@ -197,7 +205,7 @@
 			fd.friction = 0.3f;
 			m_bodies[m_bodyIndex]->CreateFixture(&fd);
 		}
-		else
+		else if (index == 4)
 		{
 			b2FixtureDef fd;
 			fd.shape = &m_circle;
@@ -206,7 +214,16 @@
 
 			m_bodies[m_bodyIndex]->CreateFixture(&fd);
 		}
+		else
+		{
+			b2FixtureDef fd;
+			fd.shape = m_capsules + (index - 5);
+			fd.density = 1.0f;
+			fd.friction = 0.3f;
 
+			m_bodies[m_bodyIndex]->CreateFixture(&fd);
+		}
+
 		m_bodyIndex = (m_bodyIndex + 1) % k_maxBodies;
 	}
 
@@ -232,6 +249,8 @@
 		case '3':
 		case '4':
 		case '5':
+		case '6':
+		case '7':
 			Create(key - '1');
 			break;
 
@@ -270,7 +289,7 @@
 		b2Color color(0.4f, 0.7f, 0.8f);
 		m_debugDraw.DrawCircle(callback.m_circle.m_p, callback.m_circle.m_radius, color);
 
-		m_debugDraw.DrawString(5, m_textLine, "Press 1-5 to drop stuff");
+		m_debugDraw.DrawString(5, m_textLine, "Press 1-7 to drop stuff");
 		m_textLine += 15;
 		m_debugDraw.DrawString(5, m_textLine, "Press 'a' to (de)activate some bodies");
 		m_textLine += 15;
@@ -287,6 +306,7 @@
 	b2Body* m_bodies[k_maxBodies];
 	b2PolygonShape m_polygons[4];
 	b2CircleShape m_circle;
+	b2CapsuleShape m_capsules[2];
 };
 
 #endif
Index: Box2D/Examples/Testbed/Tests/RayCast.h
===================================================================
--- Box2D/Examples/Testbed/Tests/RayCast.h	(revision 31)
+++ Box2D/Examples/Testbed/Tests/RayCast.h	(working copy)
@@ -106,7 +106,15 @@
 		{
 			m_circle.m_radius = 0.5f;
 		}
+		
+		{
+		    m_capsules[0].SetByExtentsX(0.5f, 0.5f);
+		}
 
+		{
+		    m_capsules[1].SetByExtentsY(0.1f, 1.8f, b2Vec2(0.0f, 1.0f), 0.0f);
+		}
+
 		m_bodyIndex = 0;
 		memset(m_bodies, 0, sizeof(m_bodies));
 
@@ -142,7 +150,7 @@
 			fd.friction = 0.3f;
 			m_bodies[m_bodyIndex]->CreateFixture(&fd);
 		}
-		else
+		else if (index == 4)
 		{
 			b2FixtureDef fd;
 			fd.shape = &m_circle;
@@ -150,7 +158,15 @@
 
 			m_bodies[m_bodyIndex]->CreateFixture(&fd);
 		}
+		else
+		{
+			b2FixtureDef fd;
+			fd.shape = m_capsules + (index - 5);
+			fd.friction = 0.3f;
 
+			m_bodies[m_bodyIndex]->CreateFixture(&fd);
+		}
+
 		m_bodyIndex = (m_bodyIndex + 1) % e_maxBodies;
 	}
 
@@ -176,6 +192,8 @@
 		case '3':
 		case '4':
 		case '5':
+		case '6':
+		case '7':
 			Create(key - '1');
 			break;
 
@@ -188,7 +206,7 @@
 	void Step(Settings* settings)
 	{
 		Test::Step(settings);
-		m_debugDraw.DrawString(5, m_textLine, "Press 1-5 to drop stuff");
+		m_debugDraw.DrawString(5, m_textLine, "Press 1-7 to drop stuff");
 		m_textLine += 15;
 
 		float32 L = 11.0f;
@@ -226,6 +244,7 @@
 	b2Body* m_bodies[e_maxBodies];
 	b2PolygonShape m_polygons[4];
 	b2CircleShape m_circle;
+	b2CapsuleShape m_capsules[2];
 
 	float32 m_angle;
 };
